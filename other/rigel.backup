#include <iostream>
#include <fstream>
#include <SFML/Graphics.hpp>
#include <SFML/Audio.hpp>
#include <sstream>
#include <string>
using namespace std;

//float to string converter
template <typename T>
string to_string(T value)
{
    ostringstream oss;
    oss << value;
    return oss.str();
}

int powerupCount;
int blockCount;
const float gravity = 400.f;
sf::RenderWindow window(sf::VideoMode(1280, 720), "alphaRigel");
bool crashed = false;
bool levelComplete = false;
int distanceCovered;
int speedValue = 25;

struct rectangleData
{
	int height;
	int width;
	int posY;
	int posX;
};

struct rectangleColumn
{
	rectangleData top;
	rectangleData bottom;
};

class blocks
{
	private:
		sf::Texture design;
	public:
		rectangleColumn value;
		static int offset;
		blocks()
		{
		}
		struct shape
		{
			sf::RectangleShape shapeTop;
			sf::RectangleShape shapeBottom;
		};
		shape drawThis;
		static void fileRead(blocks *blockList)
		{
			ifstream input("level0.map");
			for(int i = 0; i < blockCount; i++)
			{
				input.read((char*)&blockList[i].value, sizeof(blockList[i].value));
			}
			input.close();
		}
		void setValues(int x)
		{
			//might change this to class member
			//drawThis.shapeTop.setTexture(&blockTexture);
			//drawThis.shapeBottom.setTexture(&blockTexture);
			//check vector 2f
			drawThis.shapeTop.setFillColor(sf::Color(128, 0, 255));
			drawThis.shapeBottom.setFillColor(sf::Color(128, 0, 255));
			drawThis.shapeTop.setOutlineColor(sf::Color::Black);
			drawThis.shapeTop.setOutlineThickness(-7.5);
			drawThis.shapeBottom.setOutlineColor(sf::Color::Black);
			drawThis.shapeBottom.setOutlineThickness(-7.5);
			value.top.posX = x;
			value.bottom.posX = x;
			drawThis.shapeTop.setSize(sf::Vector2f(value.top.width, value.top.height));
			drawThis.shapeBottom.setSize(sf::Vector2f(value.bottom.width, value.bottom.height));
			drawThis.shapeTop.setPosition(value.top.posX, value.top.posY);
			drawThis.shapeBottom.setPosition(value.bottom.posX, value.bottom.posY);
		}
		static void moveBlocks(blocks *blockList)
		{
			offset -= speedValue;
			for(int i = 0; i < blockCount; i++)
			{
				blockList[i].setValues(i * blockList[i].value.top.width + offset);
			}
			distanceCovered += speedValue;
		}
		static void drawBlocks(blocks *blockList)
		{
			int i;
			for(i = 0; i < blockCount; i++)
			{
				window.draw(blockList[i].drawThis.shapeTop);
				window.draw(blockList[i].drawThis.shapeBottom);
			}
		}
		static void getBlockCount()
		{
			ifstream input("level0.data");
			input >> blockCount;
		}
};
int blocks::offset = 0;

class powerups: public blocks
{
	private:
		int type;
		sf::Texture design;
	public:
		static void fileReadPowerups(powerups *powerupsList)
		{
			ifstream input("level0.data");
			int temp;
			input >> temp;
			input >> temp;
			int i;
			for(i = 0; i < powerupCount; i++)
			{
                input.read((char*)&powerupsList[i].value, sizeof(powerupsList[i].value));
			}
		}
		static void getPowerupCount()
		{
            ifstream input("level0.data");
            input >> powerupCount;
            input >> powerupCount;
        }
};
class fly
{
	private:
		struct posVector
		{
			int x;
			int y;
		};
		struct velocityVector
		{
			float y;
		};
		velocityVector velocity;
		posVector position;
		int speedUpX;
		sf::Texture design;
	public:
		sf::Sprite body;
		fly()
		{
			position.x = 0;
			position.y = 0;
			speedUpX = 1;
		}
		fly(int a, int b, int c, const char *picture, blocks *blockList)
		{
			position.x = a;
			position.y = (blockList[1].value.top.posY + blockList[1].value.bottom.posY) / 2;
			speedUpX = c;
			if(!design.loadFromFile(picture));
			body.setTexture(design);
			body.setColor(sf::Color(255, 255, 255, 255));
		}
		void movement(float dt, int flag)
		{
			//position.y += 1;
			//position.x += 1 * speedUpX;
			if(flag == 1)
			{
				velocity.y -= 600.f;
			}
			if(velocity.y < gravity)
			{
				velocity.y += 10.f;
			}
			else if(velocity.y > gravity)
			{
				velocity.y = gravity;
			}
			position.y += velocity.y * dt;
			body.setPosition(position.x, position.y);
		}
		void jump(float dt)
		{
			movement(dt, 1);
		}
		void playExplosionAudio() //not working on ubuntu, try on windows?
		{
			sf::SoundBuffer explosionBuffer;
			if(!explosionBuffer.loadFromFile("explosion.wav"));
			sf::Sound explosionSound;

			explosionSound.setBuffer(explosionBuffer);
			explosionSound.setVolume(100);
			explosionSound.play();
		}
		void collisionCheck(blocks *blockList)
		{
			for(int i = 0; i < blockCount; i++)
			{
				if(body.getGlobalBounds().intersects(blockList[i].drawThis.shapeTop.getGlobalBounds()) || body.getGlobalBounds().intersects(blockList[i].drawThis.shapeBottom.getGlobalBounds()))
				{
					//playExplosionAudio(); //does not work yet

					if(!design.loadFromFile("explosion.png"));
					body.setTexture(design);
					crashed = true;
				}
			}
		}
};

int main()
{
	blocks::getBlockCount();
	sf::CircleShape shape(50);
	shape.setPosition(190, 0);
	blocks blockList[blockCount];
	int score = 0;
	window.setFramerateLimit(60);
	sf::Clock frametime;
	blocks::fileRead(blockList);
	blocks::moveBlocks(blockList);
	fly flyBody(190, 300, 1, "airplane.png", blockList);
	sf::Texture img;
	if(!img.loadFromFile("background.jpg"));
	sf::Sprite background;
	background.setTexture(img);
	bool gamePause = false;

	string scoreString;
	sf::Font scoreFont;
	scoreFont.loadFromFile("font.ttf");
	sf::Text scoreText, scoreValue;
	scoreText.setFont(scoreFont);
	scoreText.setCharacterSize(40);
	scoreText.setColor(sf::Color::White);
	scoreText.setString("SCORE: ");
	scoreText.setPosition(0, 600);
	scoreValue.setFont(scoreFont);
	scoreValue.setCharacterSize(40);
	scoreValue.setColor(sf::Color::White);
	scoreValue.setPosition(150, 600);

	while (window.isOpen())
    {
		float dt = frametime.restart().asSeconds();
        sf::Event event;
        while(window.pollEvent(event))
        {
            if(event.type == sf::Event::Closed)
            {
                window.close();
			}
			if(event.type == sf::Event::KeyPressed)
			{
				if(event.key.code == sf::Keyboard::Space && crashed == false)
				{
					flyBody.jump(dt);
				}
				if(event.key.code == sf::Keyboard::P && gamePause == false && crashed == false)
				{
					gamePause = true;
				}
				else
				{
					gamePause = false;
				}
			}
        }
        if(crashed == true)
        {
			gamePause = true;
		}
        if(distanceCovered == blockCount * 100)
        {
			gamePause = true;
		}
        if(gamePause == false)
        {
			flyBody.movement(dt, 0);
			window.clear(sf::Color::Black);
			flyBody.collisionCheck(blockList);
			window.draw(background);
			if(crashed == false)
			{
				blocks::moveBlocks(blockList);
			}
			blocks::drawBlocks(blockList);
			window.draw(flyBody.body);
			score += 10;
			scoreString = to_string(score);
			scoreValue.setString(scoreString);
			window.draw(scoreText);
			window.draw(scoreValue);
			window.display();
		}
    }

	return 0;
}
